<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Player LED - Mosaico</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        /* Estilos Globais e Reset */
        html, body {
            margin: 0; padding: 0; background: black; overflow: hidden;
            width: 100vw; height: 100vh; font-family: 'Montserrat', sans-serif;
        }

        /* Estilo base para CADA instância de player. */
        .player-instance {
            position: absolute;
            width: 400px; /* Tamanho inicial menor para mosaico */
            height: 300px;
            background: #000;
            border: 2px solid #444;
            overflow: hidden; 
            resize: both; /* ATIVADO POR PADRÃO. Será controlado pelo JS */
            display: flex; flex-direction: column;
        }

        /* Classe para destacar o Player Ativo */
        .player-ativo {
            /* ALTERAÇÃO: box-shadow removido para remover o destaque azul */
            
            z-index: 100; /* Mantido: Traz o player ativo para a frente */
        }

        .media-wrapper {
            flex-grow: 1; position: relative; background: #111;
            overflow: hidden;
        }
        .media-video, .media-fallback {
            width: 100%; height: 100%; object-fit: contain;
            position: absolute; top: 0; left: 0;
        }
        
        /* Barra Comercial (agora é por-player) */
        .barra-comercial {
            position: absolute;
            bottom: 6px;
            left: 2px;
            width: calc(100% - 4px);
            background: rgb(0 0 0 / 60%);
            color: white;
            font-size: 14px;
            display: none; /* Começa escondida */
            padding: 10px;
            box-sizing: border-box;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            border-radius: 14px;
        }
        .barra-comercial .info-alternada { transition: opacity 0.5s ease; flex-grow: 1; }
        .barra-comercial .hora { font-size: 24px; font-weight: bold; }

        .icon-decorado {
            width: 20px;
            height: 20px;
            background: #ffffff;
            padding: 4px;
            border-radius: 6px;
            filter: brightness(0.50) invert(1);
            margin-right: 10px;
        }

        /* Relógio (Elemento global, não é por-player) */
        #relogio-box {
            position: absolute; width: 100%;
            background: black; color: white;
            display: none; justify-content: center; align-items: center;
            font-size: 60px; font-weight: bold; z-index: 20;
        }
        .blink { animation: blink 1s step-start infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        /* Estilos dos Menus (Principal e Controladora) */
        #controls-container, #controladora-container {
            position: fixed; top: 50%; left: 50%;
            z-index: 300; display: none;
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
        }
        
        #controladora-container {
            z-index: 301; /* Fica por cima do menu principal */
        }

        .menu-grid {
            list-style: none; margin: 0; padding: 0;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            border: 1px solid #4a4e69;
        }
        .menu-grid li { width: 150px; height: 120px; display: flex; justify-content: center; align-items: center; border: 1px solid #4a4e69; background-color: rgba(34, 34, 59, 0.95); cursor: pointer; -webkit-transition: background-color 0.4s ease-in-out; transition: background-color 0.4s ease-in-out; }
        .menu-grid li:hover { background-color: #4a4e69; }
        .menu-grid li a { text-decoration: none; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #FFF; font-size: 14px; text-transform: capitalize; text-align: center; width: 100%; height: 100%; }
        .menu-grid li i { margin-bottom: 15px; }
        .menu-grid li a.active { background-color: #007bff; }
        
        /* Estilo para o Seletor de Player */
        .menu-grid li.controladora-select {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 14px;
            grid-column: span 2; /* Faz o seletor ocupar 2 espaços */
        }
        .menu-grid li.controladora-select label {
            margin-bottom: 10px;
            font-weight: bold;
        }
        #player-selector {
            background: #333;
            color: white;
            border: 1px solid #4a4e69;
            padding: 8px;
            border-radius: 5px;
            width: 80%;
        }

        /* Modal Preset Livre */
        #preset-livre-modal {
            display: none;
            position: fixed; top: 50%; left: 50%;
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
            background-color: #22223b;
            color: white;
            padding: 30px;
            border: 1px solid #4a4e69;
            border-radius: 10px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            z-index: 400;
            width: 300px;
        }
        #preset-livre-modal h3 { margin-top: 0; text-align: center; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; }
        .input-group input { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #4a4e69; background: #333; color: white; box-sizing: border-box; }
        .modal-botoes { text-align: right; }
        .modal-botoes button { background: #4a4e69; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        .modal-botoes button:hover { background: #5a5e79; }

        /* Overlay de Corte (agora por-player) */
        .selection-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            cursor: crosshair;
            z-index: 50;
            display: none;
        }
        .selection-box {
            position: absolute;
            border: 2px dashed #fff;
            box-sizing: border-box;
        }

    </style>
</head>
<body>

    <div id="relogio-box"></div>

    <input type="file" id="mediaInput" accept="video/mp4,image/*" style="display: none;" multiple>

    <div id="preset-livre-modal">
        <h3>Preset Personalizado</h3>
        <div class="input-group">
            <label for="input-x">Posição X (px)</label>
            <input type="number" id="input-x" value="100">
        </div>
        <div class="input-group">
            <label for="input-y">Posição Y (px)</label>
            <input type="number" id="input-y" value="100">
        </div>
        <div class="input-group">
            <label for="input-largura">Largura (px)</label>
            <input type="number" id="input-largura" value="800">
        </div>
        <div class="input-group">
            <label for="input-altura-midia">Altura Mídia (Relógio) (px)</label>
            <input type="number" id="input-altura-midia" value="480">
        </div>
        <div class="input-group">
            <label for="input-altura">Altura (px)</label>
            <input type="number" id="input-altura" value="600">
        </div>
        <div class="modal-botoes">
            <button onclick="fecharModalPresetLivre()">Cancelar</button>
            <button onclick="aplicarPresetLivre()">Aplicar</button>
        </div>
    </div>

    <div id="controls-container">
        <ul class="menu-grid">
            <li><a href="#" onclick="addMedia()"><i class="fa fa-plus fa-2x"></i>Add Mídia</a></li>
            <li><a href="#" onclick="lerGradePasta()"><i class="fa fa-folder-open fa-2x"></i>Ler Grade</a></li>
            
            <li><a href="#" onclick="aplicarLayout('mub')"><i class="fa fa-desktop fa-2x"></i>Mub Premium</a></li>
            <li><a href="#" onclick="aplicarLayout('relogio')"><i class="fa fa-clock fa-2x"></i>Relógio</a></li>
            <li><a href="#" onclick="aplicarLayout('coluna')"><i class="fa fa-columns fa-2x"></i>Coluna</a></li>
            <li><a href="#" onclick="abrirModalPresetLivre()"><i class="fa fa-ruler-combined fa-2x"></i>Preset Livre</a></li>
            
            <li><a href="#" onclick="toggleBarraComercial()"><i class="fa fa-bars fa-2x"></i>Alternar Barra</a></li>
            <li><a href="#" onclick="toggleFullscreen()"><i class="fa fa-expand fa-2x"></i>Tela Cheia</a></li>
            <li><a href="#" onclick="resetMidias()"><i class="fa fa-trash fa-2x"></i>Resetar</a></li>
            <li id="move-button-li"><a href="#" onclick="toggleMover(this)"><i class="fa fa-arrows-alt fa-2x"></i>Ajustar Posição</a></li>
            <li><a href="#" onclick="mostrarMenuControladora(true)"><i class="fa fa-cogs fa-2x"></i>Controladora</a></li> 
            <li><a href="#" onclick="toggleControls()"><i class="fa fa-eye-slash fa-2x"></i>Ocultar Menu</a></li>
            
            <li><a href="#" onclick="ajustarModo('contain', this)"><i class="fa fa-compress fa-2x"></i>Ajustar</a></li>
            <li><a href="#" onclick="ajustarModo('fill', this)"><i class="fa fa-expand-arrows-alt fa-2x"></i>Esticar</a></li>
            <li><a href="#" onclick="ajustarModo('cover', this)"><i class="fa fa-clone fa-2x"></i>Preencher</a></li>
            <li><a href="#" onclick="rotacionarMidia()"><i class="fa fa-redo fa-2x"></i>Rotacionar</a></li>
            <li><a href="#" onclick="resetarLayout()"><i class="fa fa-undo fa-2x"></i>Resetar Layout</a></li>
            <li><a href="#" onclick="salvarConfiguracao()"><i class="fa fa-save fa-2x"></i>Salvar</a></li>
            
            <li><a href="#" onclick="carregarConfiguracao()"><i class="fa fa-folder-open fa-2x"></i>Carregar</a></li>
            <li><a href="#" onclick="toggleCortar(this)"><i class="fa fa-crop-alt fa-2x"></i>Cortar Mídia</a></li>
        </ul>
    </div>
    
    <div id="controladora-container">
        <ul class="menu-grid">
            <li><a href="#" onclick="voltarMenuPrincipal()"><i class="fa fa-arrow-left fa-2x"></i>Voltar</a></li>
            <li><a href="#" onclick="adicionarPlayer()"><i class="fa fa-plus-square fa-2x"></i>Add Player</a></li>
            <li><a href="#" onclick="sincronizarPlayers()"><i class="fa fa-sync fa-2x"></i>Sincronizar</a></li>
            <li><a href="#" onclick="removerPlayer()"><i class="fa fa-trash fa-2x"></i>Remover</a></li>
            
            <li class="controladora-select">
                <label for="player-selector">Player Ativo:</label>
                <select id="player-selector" onchange="selecionarPlayer(this.value)">
                </select>
            </li>
        </ul>
    </div>

<script>
    // --- VARIÁVEIS GLOBAIS DE CONTROLE ---
    const controlsContainer = document.getElementById('controls-container');
    const controladoraContainer = document.getElementById('controladora-container');
    const playerSelector = document.getElementById('player-selector');
    const mediaInput = document.getElementById('mediaInput');
    const presetLivreModal = document.getElementById('preset-livre-modal');
    const relogioBox = document.getElementById('relogio-box');
    
    // --- DURAÇÃO PARA IMAGENS ---
    const IMAGE_DURATION = 7000; // 7 segundos
    
    // --- (NOVA) DURAÇÃO DA VERIFICAÇÃO DA GRADE ---
    const GRADE_CHECK_INTERVAL_MS = 10000; // Verificar a pasta a cada 10 segundos

    // --- VARIÁVEIS DE ESTADO DA APLICAÇÃO ---
    let players = []; // Array para guardar todos os nossos players
    let playerAtivo = null; // Referência ao objeto do player selecionado
    let playerCounter = 0; // Contador para dar IDs únicos
    let commercialBarInterval = null; // Intervalo da barra comercial (global)

    // --- VARIÁVEIS DE ESTADO DE INTERAÇÃO ---
    let moverAtivo = false;
    let cortarAtivo = false;
    let isDragging = false;
    let isSelecting = false;
    let offsetX = 0, offsetY = 0;


    // ========================================================================
    // --- FUNÇÕES DA CONTROLADORA (NOVA ARQUITETURA) ---
    // ========================================================================

    /**
     * Retorna o HTML de um novo player.
     * @param {number} id - O ID numérico do player.
     */
    function getPlayerTemplate(id) {
        // IDs são únicos para o container, classes são usadas para os elementos internos
        // (MODIFICADO) Removido o atributo 'loop' do <video>
        return `
            <div class="media-wrapper">
                <video class="media-video" autoplay muted playsinline></video>
                <img class="media-fallback" style="display: none;" />
                <div class="selection-overlay">
                    <div class="selection-box"></div>
                </div>
            </div>
            <div class="barra-comercial">
                <div class="info-alternada"></div>
                <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTSngqZzv7e6QBJRAN9L8zXvB9deAVNWW6tXQ&s" alt="Logo" style="height:24px; margin-right:10px; vertical-align:middle;">
                <span class="hora"></span>
            </div>
        `;
    }

    /**
     * Cria e registra um novo player.
     */
    function adicionarPlayer() {
        playerCounter++;
        const newPlayerContainer = document.createElement('div');
        newPlayerContainer.id = `player-container-${playerCounter}`;
        newPlayerContainer.className = 'player-instance';
        
        // Define uma posição inicial escalonada
        newPlayerContainer.style.top = `${50 + (playerCounter * 20)}px`;
        newPlayerContainer.style.left = `${50 + (playerCounter * 20)}px`;

        newPlayerContainer.innerHTML = getPlayerTemplate(playerCounter);
        document.body.appendChild(newPlayerContainer);

        // (MODIFICADO) Cria o objeto de referência para este player
        const newPlayer = {
            id: playerCounter,
            container: newPlayerContainer,
            media: newPlayerContainer.querySelector('.media-video'),
            fallback: newPlayerContainer.querySelector('.media-fallback'),
            mediaAtiva: newPlayerContainer.querySelector('.media-video'),
            barraComercial: newPlayerContainer.querySelector('.barra-comercial'),
            infoAlternada: newPlayerContainer.querySelector('.info-alternada'),
            hora: newPlayerContainer.querySelector('.hora'),
            overlay: newPlayerContainer.querySelector('.selection-overlay'),
            selectionBox: newPlayerContainer.querySelector('.selection-box'),
            rotacao: 0,
            // Estado do 'crop'
            crop: { x: 0, y: 0, w: 0, h: 0 },
            
            // --- PROPRIEDADES DA PLAYLIST ---
            playlist: [],      // Array para os ficheiros (File objects)
            playlistIndex: 0, // Índice da mídia atual
            imageTimeout: null,  // Timer para mídias de imagem
            
            // --- (NOVAS) PROPRIEDADES DE GRADE (POR-PLAYER) ---
            gradeDirectoryHandle: null,
            gradeCheckInterval: null
        };

        // --- Anexa os ouvintes de evento (listeners) A ESTE player ---
        adicionarListenersAoPlayer(newPlayer);
        
        // Adiciona ao array e ao seletor
        players.push(newPlayer);
        
        const option = document.createElement('option');
        option.value = newPlayer.id;
        option.textContent = `Player ${newPlayer.id}`;
        playerSelector.appendChild(option);

        // Seleciona o player recém-criado
        selecionarPlayer(newPlayer.id);
        voltarMenuPrincipal(); // Fecha o menu da controladora
    }
    
    /**
     * Remove o player ativo.
     */
    function removerPlayer() {
        if (!playerAtivo) {
            alert("Nenhum player selecionado para remover.");
            return;
        }
        
        if (players.length <= 1) {
            alert("Não é possível remover o último player.");
            return;
        }
        
        const idParaRemover = playerAtivo.id;
        
        // (MODIFICADO) Limpa o timer de imagem E O TIMER DE GRADE
        if (playerAtivo.imageTimeout) clearTimeout(playerAtivo.imageTimeout);
        if (playerAtivo.gradeCheckInterval) {
            clearInterval(playerAtivo.gradeCheckInterval);
        }

        // Remove do HTML
        playerAtivo.container.remove();
        
        // Remove do seletor
        playerSelector.querySelector(`option[value="${idParaRemover}"]`).remove();
        
        // Remove do array
        players = players.filter(p => p.id !== idParaRemover);
        
        // Seleciona o primeiro player restante
        selecionarPlayer(players[0].id);
    }

    /**
     * Anexa todos os listeners de Drag (mover) e Crop (cortar)
     * a uma instância específica do player.
     * @param {object} player - O objeto do player (newPlayer)
     */
    function adicionarListenersAoPlayer(player) {
        
        // --- Listener de Mover (Drag) ---
        player.container.addEventListener('mousedown', (e) => {
            // Só ativa o drag se 'moverAtivo' estiver ligado
            // E se o clique não foi no 'resize' (canto inferior direito)
            if (moverAtivo && e.target === player.container) {
                
                // Se o player clicado não for o ativo, torna-o ativo
                if (player.id !== playerAtivo.id) {
                    selecionarPlayer(player.id);
                }
                
                isDragging = true;
                offsetX = e.clientX - player.container.offsetLeft;
                offsetY = e.clientY - player.container.offsetTop;
                player.container.style.cursor = 'move';
            }
        });

        // --- Listeners de Cortar (Crop) ---
        let startX, startY;

        player.overlay.addEventListener('mousedown', (e) => {
            if (!cortarAtivo) return;
            e.preventDefault();
            isSelecting = true;
            startX = e.clientX - player.overlay.getBoundingClientRect().left;
            startY = e.clientY - player.overlay.getBoundingClientRect().top;
            player.selectionBox.style.left = `${startX}px`;
            player.selectionBox.style.top = `${startY}px`;
            player.selectionBox.style.width = '0px';
            player.selectionBox.style.height = '0px';
            player.selectionBox.style.display = 'block';
        });

        player.overlay.addEventListener('mousemove', (e) => {
            if (!isSelecting) return;
            const currentX = e.clientX - player.overlay.getBoundingClientRect().left;
            const currentY = e.clientY - player.overlay.getBoundingClientRect().top;
            const width = currentX - startX;
            const height = currentY - startY;

            player.selectionBox.style.width = `${Math.abs(width)}px`;
            player.selectionBox.style.height = `${Math.abs(height)}px`;
            player.selectionBox.style.left = `${width > 0 ? startX : currentX}px`;
            player.selectionBox.style.top = `${height > 0 ? startY : currentY}px`;
        });

        player.overlay.addEventListener('mouseup', (e) => {
            if (!isSelecting) return;
            isSelecting = false;
            player.selectionBox.style.display = 'none';
            
            const rect = {
                x: parseFloat(player.selectionBox.style.left),
                y: parseFloat(player.selectionBox.style.top),
                width: parseFloat(player.selectionBox.style.width),
                height: parseFloat(player.selectionBox.style.height)
            };

            if (rect.width > 0 && rect.height > 0) {
                const containerWidth = player.overlay.offsetWidth;
                const containerHeight = player.overlay.offsetHeight;

                // Calcula a escala e posição para o 'object-fit: cover'
                const scaleX = containerWidth / rect.width;
                const scaleY = containerHeight / rect.height;
                const newWidth = player.mediaAtiva.offsetWidth * scaleX;
                const newHeight = player.mediaAtiva.offsetHeight * scaleY;
                const newLeft = -rect.x * scaleX;
                const newTop = -rect.y * scaleY;
                
                // Aplica o "corte"
                player.mediaAtiva.style.objectFit = 'cover';
                player.mediaAtiva.style.width = `${newWidth}px`;
                player.mediaAtiva.style.height = `${newHeight}px`;
                player.mediaAtiva.style.top = `${newTop}px`;
                player.mediaAtiva.style.left = `${newLeft}px`;

                // Salva o estado do corte
                player.crop = { x: newLeft, y: newTop, w: newWidth, h: newHeight };

                // Desativa a ferramenta de corte
                toggleCortar(document.querySelector('.menu-grid a[onclick*="toggleCortar"]'));
            }
        });

        // --- (NOVO) Listener de Fim de Mídia (para playlist) ---
        // Quando o vídeo (media) deste player terminar, chama a função playNextMedia
        player.media.addEventListener('ended', () => playNextMedia(player));
    }

    // Listeners GLOBAIS para mover (arrastar)
    // Eles operam sobre o 'playerAtivo' que foi definido no 'mousedown'
    document.addEventListener('mousemove', (e) => {
        if (isDragging && moverAtivo && playerAtivo) {
            playerAtivo.container.style.left = `${e.clientX - offsetX}px`;
            playerAtivo.container.style.top = `${e.clientY - offsetY}px`;
            playerAtivo.container.style.transform = `none`; // Remove o transform para o drag funcionar
        }
    });
    document.addEventListener('mouseup', () => {
        if (isDragging && playerAtivo) {
            playerAtivo.container.style.cursor = 'default';
        }
        isDragging = false;
    });


    /**
     * Define qual player está ativo para receber comandos.
     * @param {string | number} playerId - O ID do player.
     */
    function selecionarPlayer(playerId) {
        const id = parseInt(playerId);
        
        // Salva o player antigo
        const playerAntigo = playerAtivo;

        // Remove a classe e restaura o resize do player antigo
        if (playerAntigo) {
            playerAntigo.container.classList.remove('player-ativo');
            // *** AJUSTE ***
            // Restaura o resize no player antigo para o padrão
            playerAntigo.container.style.resize = 'both'; 
        }
        
        // Encontra e define o novo player ativo
        playerAtivo = players.find(p => p.id === id);
        
        if (playerAtivo) {
            playerAtivo.container.classList.add('player-ativo');
            playerSelector.value = id; // Sincroniza o <select>
            
            // *** AJUSTE ***
            // Aplica o estado de 'moverAtivo' ao novo player
            if (moverAtivo) {
                // Se o modo Mover está ativo, desativa o resize
                playerAtivo.container.style.resize = 'none';
            } else {
                // Se o modo Mover está inativo, ativa o resize
                playerAtivo.container.style.resize = 'both';
            }
        }
    }

    /**
     * Sincroniza todos os vídeos, fazendo-os começar do segundo 0.
     * (NOTA: Isto não sincroniza playlists, apenas reinicia a mídia ATUAL de todos)
     */
    function sincronizarPlayers() {
        if (players.length === 0) return;
        
        players.forEach(player => {
            // (MODIFICADO) Reinicia a playlist se houver uma, ou a mídia atual
            if (player.playlist.length > 0) {
                player.playlistIndex = 0;
                loadPlayerMedia(player);
            } 
            else if (player.media && player.media.src) {
                player.media.currentTime = 0;
                player.media.play();
            }
        });
        alert(`Sincronia enviada para ${players.length} players.`);
    }

    // ========================================================================
    // --- FUNÇÕES DE CONTROLE (REFATORADAS PARA O 'playerAtivo') ---
    // ========================================================================

    function checkPlayerAtivo() {
        if (!playerAtivo) {
            alert("Nenhum player está selecionado. Adicione um player ou selecione um no menu 'Controladora'.");
            return false;
        }
        return true;
    }

// --- Funções dos Menus ---
    function toggleControls() { controlsContainer.style.display = (controlsContainer.style.display === 'block') ? 'none' : 'block'; controladoraContainer.style.display = 'none'; }
    function mostrarMenuControladora(ocultarPrincipal = true) { if (ocultarPrincipal) { controlsContainer.style.display = 'none'; } controladoraContainer.style.display = 'block'; }
    function voltarMenuPrincipal() { controladoraContainer.style.display = 'none'; controlsContainer.style.display = 'block'; }
    function toggleFullscreen() { if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); }
    document.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'm') { toggleControls(); } });
    
    // --- Funções de Mídia ---
    function addMedia() {
        if (!checkPlayerAtivo()) return;
        mediaInput.click();
    }
    
    /**
     * (MODIFICADO) Manipulador de seleção de ficheiros.
     * Agora adiciona todos os ficheiros selecionados à playlist do player ativo.
     * Também interrompe o monitoramento de grade.
     */
    mediaInput.onchange = (event) => {
        if (!checkPlayerAtivo()) return; 
        const pa = playerAtivo;
        
        // --- (MODIFICADO) Interrompe o monitoramento de grade se mídias manuais forem adicionadas
        if (pa.gradeCheckInterval) {
            clearInterval(pa.gradeCheckInterval);
            pa.gradeCheckInterval = null;
            pa.gradeDirectoryHandle = null;
            console.log(`Monitoramento de grade interrompido para o Player ${pa.id} (mídias manuais).`);
        }
        
        const files = Array.from(event.target.files); // Pega TODOS os ficheiros
        if (files.length === 0) return;

        // Verifica se a playlist estava vazia antes de adicionar
        const wasEmpty = pa.playlist.length === 0;
        
        // Adiciona os novos ficheiros à playlist existente
        pa.playlist = pa.playlist.concat(files);

        // Se a playlist estava vazia e agora tem ficheiros, inicia a reprodução
        if (wasEmpty && pa.playlist.length > 0) {
            loadPlayerMedia(pa);
        }
        
        event.target.value = null; // Limpa o input para permitir selecionar os mesmos Ficheiros
    };

    /**
     * (MODIFICADO) Reseta a mídia, a playlist E o monitoramento de grade do player ativo.
     */
    function resetMidias() {
        if (!checkPlayerAtivo()) return;
        const pa = playerAtivo;
        
        // --- (MODIFICADO) Interrompe o monitoramento de grade deste player ---
        if (pa.gradeCheckInterval) {
            clearInterval(pa.gradeCheckInterval);
            pa.gradeCheckInterval = null;
            pa.gradeDirectoryHandle = null;
            console.log(`Monitoramento de grade interrompido para o Player ${pa.id}.`);
        }
        
        // (NOVO) Limpa o timer de imagem, se houver
        if (pa.imageTimeout) clearTimeout(pa.imageTimeout);

        // (NOVO) Limpa a playlist
        pa.playlist = [];
        pa.playlistIndex = 0;
        pa.imageTimeout = null;

        // Para a mídia atual
        pa.media.pause();
        pa.media.removeAttribute('src');
        pa.fallback.removeAttribute('src');
        pa.media.load();
        
        // Garante que o vídeo pare de ser exibido
        pa.media.style.display = 'block'; 
        pa.fallback.style.display = 'none';

        resetarCorte();
    }


    // --- (NOVAS) FUNÇÕES DE CONTROLE DE PLAYLIST ---
    
    /**
     * Carrega a mídia atual da playlist no player especificado.
     * @param {object} player - O objeto do player.
     */
    function loadPlayerMedia(player) {
        if (player.playlist.length === 0) return;

        // Limpa qualquer temporizador de imagem anterior
        if (player.imageTimeout) clearTimeout(player.imageTimeout);

        const file = player.playlist[player.playlistIndex];
        
        // (NOVO) Tratamento de erro
        if (!file) {
            console.error(`Erro: Mídia inválida no índice ${player.playlistIndex} para o Player ${player.id}.`);
            // Tenta avançar para não parar o player
            playNextMedia(player);
            return;
        }
        
        const url = URL.createObjectURL(file);

        if (file.type.startsWith('video')) {
            player.fallback.style.display = 'none';
            player.media.style.display = 'block';
            player.media.src = url;
            player.media.play().catch(e => console.error(`Erro ao reproduzir vídeo no Player ${player.id}:`, e));
            player.mediaAtiva = player.media;
        } else { // Se for uma imagem
            player.media.style.display = 'none';
            player.fallback.style.display = 'block';
            player.fallback.src = url;
            player.mediaAtiva = player.fallback;
            
            // Inicia um temporizador para passar para a próxima mídia
            player.imageTimeout = setTimeout(() => playNextMedia(player), IMAGE_DURATION);
        }
        
        // (NOVO) Reaplica o corte/transformação, se houver
        reaplicarEstilosMidia(player);
    }

    /**
     * Avança para a próxima mídia na playlist do player especificado.
     * @param {object} player - O objeto do player.
     */
    function playNextMedia(player) {
        if (player.playlist.length > 0) {
            // O operador % (módulo) garante o loop infinito
            player.playlistIndex = (player.playlistIndex + 1) % player.playlist.length; 
            loadPlayerMedia(player);
        }
    }
    
    /**
     * (NOVA) Reaplica estilos (crop, rotação) à mídia ativa.
     * Necessário ao trocar de item na playlist.
     */
    function reaplicarEstilosMidia(player) {
        const pa = player; // usa o player passado como argumento
        
        // Reaplica Rotação
        const transformValue = `rotate(${pa.rotacao}deg)`; 
        pa.mediaAtiva.style.webkitTransform = transformValue; 
        pa.mediaAtiva.style.transform = transformValue; 
        
        // Reaplica Corte (Crop)
        if (pa.crop && pa.crop.w > 0) {
            // Se tem corte salvo, aplica
            pa.mediaAtiva.style.objectFit = 'cover';
            pa.mediaAtiva.style.width = `${pa.crop.w}px`;
            pa.mediaAtiva.style.height = `${pa.crop.h}px`;
            pa.mediaAtiva.style.top = `${pa.crop.y}px`;
            pa.mediaAtiva.style.left = `${pa.crop.x}px`;
        } else {
            // Se não tem corte, aplica o modo de ajuste padrão (ex: 'contain')
            pa.mediaAtiva.style.objectFit = pa.media.style.objectFit || 'contain';
            pa.mediaAtiva.style.width = '100%';
            pa.mediaAtiva.style.height = '100%';
            pa.mediaAtiva.style.top = '0';
            pa.mediaAtiva.style.left = '0';
        }
    }
    
    // --- (NOVAS) FUNÇÕES DE LEITURA DE GRADE (POR-PLAYER) ---

    /**
     * (NOVA) Inicia o processo de seleção de pasta para monitoramento (grade).
     * Aplica-se ao player ATIVO.
     */
    async function lerGradePasta() {
        // 1. Verifica se o navegador suporta a API
        if (!window.showDirectoryPicker) {
            alert('Erro: O seu navegador não suporta a seleção de pastas ou a página não está em HTTPS/localhost.');
            return;
        }
        
        // 2. Verifica se há um player ativo
        if (!checkPlayerAtivo()) {
            // O checkPlayerAtivo() já emite um alerta
            return;
        }
        
        const pa = playerAtivo; // Pega o player ativo

        try {
            // 3. Pede ao utilizador para selecionar uma pasta
            const handle = await window.showDirectoryPicker();
            
            // 4. Limpa qualquer playlist ou monitoramento anterior DESTE player
            // A função resetMidias() já lida com a limpeza dos intervalos do 'pa'
            resetMidias(); 
            
            // 5. Armazena a referência da pasta NO OBJETO DO PLAYER
            pa.gradeDirectoryHandle = handle;
            console.log(`Iniciando monitoramento de grade para o Player ${pa.id} (Pasta: ${handle.name})`);

            // 6. Faz a primeira verificação imediatamente, passando o player
            await scanGradeDirectory(pa);
            
            // 7. Inicia o "timer" para verificar a pasta periodicamente
            // O ID do intervalo é armazenado NO OBJETO DO PLAYER
            pa.gradeCheckInterval = setInterval(() => scanGradeDirectory(pa), GRADE_CHECK_INTERVAL_MS);

        } catch (err) {
            // O utilizador pode ter cancelado a seleção
            console.error("Erro ao selecionar a pasta ou permissão negada:", err);
        }
    }

    /**
     * (NOVA) Verifica a pasta de grade de UM player específico.
     * @param {object} player - O objeto do player a ser verificado.
     */
    async function scanGradeDirectory(player) {
        // 1. Verifica se o player e seu handle de grade são válidos
        if (!player || !player.gradeDirectoryHandle) {
            // Se o handle foi limpo (ex: por resetMidias), para a verificação
            if (player && player.gradeCheckInterval) {
                 clearInterval(player.gradeCheckInterval);
                 player.gradeCheckInterval = null;
            }
            return;
        }

        let foundFiles = [];
        
        try {
            // 2. Itera sobre os arquivos na pasta do player
            for await (const entry of player.gradeDirectoryHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/^video\d+\.mp4$/i)) {
                    foundFiles.push(entry);
                }
            }

            // 3. Ordena os arquivos numericamente
            foundFiles.sort((a, b) => {
                const numA = parseInt(a.name.match(/(\d+)/)[1]);
                const numB = parseInt(b.name.match(/(\d+)/)[1]);
                return numA - numB; // Ordena do menor para o maior
            });

            // 4. Compara a lista encontrada com a playlist atual DO PLAYER
            const newPlaylistNames = foundFiles.map(f => f.name);
            const oldPlaylistNames = player.playlist.map(f => f.name);

            // 5. Se houver diferença, atualiza a playlist
            if (JSON.stringify(newPlaylistNames) !== JSON.stringify(oldPlaylistNames)) {
                console.log(`Mudança na grade detetada para o Player ${player.id}. Atualizando...`);
                console.log("Arquivos encontrados:", newPlaylistNames.join(', '));
                
                const fileObjects = await Promise.all(
                    foundFiles.map(fileHandle => fileHandle.getFile())
                );

                // 7. Atualiza a playlist DO PLAYER
                player.playlist = fileObjects;
                player.playlistIndex = 0;
                
                // 8. Carrega a nova mídia (se a playlist não estiver vazia)
                if (player.playlist.length > 0) {
                    loadPlayerMedia(player);
                } else {
                    // Se a pasta ficou vazia, limpa o player
                    if (player.imageTimeout) clearTimeout(player.imageTimeout);
                    player.media.pause();
                    player.media.removeAttribute('src');
                    player.fallback.removeAttribute('src');
                    player.media.load();
                }
            }
            
        } catch (err) {
            console.error(`Erro ao ler a pasta da grade do Player ${player.id}. A permissão pode ter sido revogada.`, err);
            
            // Se der erro (ex: pasta apagada), para o monitoramento DESTE player
            if (player.gradeCheckInterval) {
                clearInterval(player.gradeCheckInterval);
                player.gradeCheckInterval = null;
            }
            player.gradeDirectoryHandle = null;
            
            // Limpa a mídia deste player
            if (player.imageTimeout) clearTimeout(player.imageTimeout);
            player.playlist = [];
            player.playlistIndex = 0;
            player.media.pause();
            player.media.removeAttribute('src');
            player.media.removeAttribute('src');
            player.media.load();
        }
    }


    // --- Funções de Layout e Posição ---
    
    /**
     * Alterna o modo de Mover (arrastar) e desativa/ativa
     * a capacidade de redimensionar (resize).
     */
    function toggleMover(element) {
        if (!checkPlayerAtivo()) {
            element.classList.remove('active'); // Garante que não fique ativo se não houver player
            return;
        }
        
        moverAtivo = !moverAtivo;
        element.classList.toggle('active', moverAtivo);
        
        if (moverAtivo) {
            // MODO MOVER ATIVO: Desativa o resize
            playerAtivo.container.style.resize = 'none';
            
            // Desativa o 'cortar' se 'mover' for ativado
            if (cortarAtivo) {
                toggleCortar(document.querySelector('.menu-grid a[onclick*="toggleCortar"]'));
            }
        } else {
            // MODO MOVER INATIVO: Ativa o resize
            playerAtivo.container.style.resize = 'both';
        }
    }
    
    /**
     * Esta função (Esticar) apenas muda o object-fit da mídia.
     */
    function ajustarModo(modo, element) { 
        if (!checkPlayerAtivo()) return;
        document.querySelectorAll('.menu-grid a[onclick*="ajustarModo"]').forEach(a => a.classList.remove('active')); 
        element.classList.add('active'); 
        
        // (MODIFICADO) Reseta o corte E APLICA o novo modo
        resetarCorte(); 
        playerAtivo.media.style.objectFit = modo; 
        playerAtivo.fallback.style.objectFit = modo; 
    }
    
    function rotacionarMidia() { 
        if (!checkPlayerAtivo()) return;
        const pa = playerAtivo;
        pa.rotacao = (pa.rotacao + 90) % 360; 
        
        // (MODIFICADO) Chama a função de reaplicar para atualizar a mídia ativa
        reaplicarEstilosMidia(pa);
    }
    
    function resetarLayout() { 
        if (!checkPlayerAtivo()) return;
        const pa = playerAtivo;
        
        pa.barraComercial.style.display = 'none'; 
        if (commercialBarInterval) { // Resetar para todos os players
             clearInterval(commercialBarInterval);
             commercialBarInterval = null;
        }
        relogioBox.style.display = 'none';
        
        pa.container.style.top = '50%'; 
        pa.container.style.left = '50%'; 
        pa.container.style.width = '400px'; 
        pa.container.style.height = '300px'; 
        pa.container.style.transform = 'translate(-50%, -50%)'; 
        pa.container.style.resize = 'both'; // Garante que o resize volte ao padrão
        resetarCorte();
    }

    function aplicarLayout(preset) {
        if (!checkPlayerAtivo()) return;
        const pa = playerAtivo;
        
        resetarLayout(); 
        pa.container.style.transform = 'none';
        
        if (commercialBarInterval) clearInterval(commercialBarInterval);
        relogioBox.style.display = 'none';

        if (preset === 'mub') { 
            pa.container.style.top = '0px'; 
            pa.container.style.left = '0px'; 
            pa.container.style.width = '960px'; 
            pa.container.style.height = '480px'; 
        }
        else if (preset === 'relogio') { 
            // Pega o valor do novo input de Altura da Mídia (padrão é 480)
            const alturaMidia = document.getElementById('input-altura-midia').value;
            const larguraPlayer = '280px'; // Largura fixa do layout Relógio
            const alturaRelogio = '80px'; // Altura fixa do relógio
            
            pa.container.style.top = '0px'; 
            pa.container.style.left = '0px'; 
            pa.container.style.width = larguraPlayer; 
            // Usa o valor da altura da mídia do input
            pa.container.style.height = `${alturaMidia}px`; 
            
            relogioBox.style.display = 'flex'; 
            // A posição Y do relógio é o final da mídia
            relogioBox.style.top = `${alturaMidia}px`; 
            relogioBox.style.left = '0px'; 
            relogioBox.style.width = larguraPlayer; 
            relogioBox.style.height = alturaRelogio; 
            
            const updateClock = () => { relogioBox.innerHTML = new Date().toLocaleTimeString('pt-BR', {hour: '2-digit', minute:'2-digit'}).replace(':', '<span class="blink">:</span>'); }; 
            updateClock(); 
            commercialBarInterval = setInterval(updateClock, 1000); 
        }
        else if (preset === 'coluna') {
            pa.container.style.top = '0px'; 
            pa.container.style.left = '0px'; 
            pa.container.style.width = '768px'; 
            pa.container.style.height = '960px';
            pa.barraComercial.style.display = 'flex';
            
            const informacoes = [ 
                `<div style="display: flex; align-items: center; gap: 8px;"><img src='https://cdn-icons-png.flaticon.com/512/3358/3358623.png' class='icon-decorado' alt='Ícone Mercado'><span style="font-size: 10px; color: #ccc;">ÍNDICES</span><span>IBOV</span><span style="color: #2ecc71;">+0,4%</span><span style="background: #2ecc71; color: white; font-size: 9px; padding: 2px 4px; border-radius: 4px;">137.824</span></div>`, 
                `<div style="display: flex; align-items: center; gap: 8px;"><img src='https://cdn-icons-png.flaticon.com/512/3358/3358623.png' class='icon-decorado' alt='Ícone Mercado'><span style="font-size: 10px; color: #ccc;">DÓLAR</span><span style="font-weight: bold;">R$ 5,45</span><span style="background-color: #e74c3c; color: white; font-size: 9px; padding: 2px 4px; border-radius: 4px;">-0.27%</span></div>` 
            ];
            let infoIndex = 0;
            
            const updateInfo = () => { 
                const infoEl = pa.infoAlternada;
                if (!infoEl) return;
                infoEl.style.opacity = 0; 
                setTimeout(() => { infoEl.innerHTML = informacoes[infoIndex]; infoEl.style.opacity = 1; infoIndex = (infoIndex + 1) % informacoes.length; }, 500); 
            };
            
            const atualizarHora = () => { 
                const horaEl = pa.hora;
                if(horaEl) horaEl.textContent = new Date().toLocaleTimeString('pt-BR', {hour: '2-digit', minute:'2-digit'}); 
            };
            
            atualizarHora(); updateInfo();
            commercialBarInterval = setInterval(() => { updateInfo(); atualizarHora(); }, 4000);
        }
    }
    
    function toggleBarraComercial() {
        if (!checkPlayerAtivo()) return;
        const pa = playerAtivo;
        pa.barraComercial.style.display = (pa.barraComercial.style.display === 'flex') ? 'none' : 'flex';
    }
    
    function abrirModalPresetLivre() { 
        if (!checkPlayerAtivo()) return;
        const pa = playerAtivo;
        document.getElementById('input-x').value = pa.container.offsetLeft;
        document.getElementById('input-y').value = pa.container.offsetTop;
        document.getElementById('input-largura').value = pa.container.offsetWidth;
        document.getElementById('input-altura').value = pa.container.offsetHeight;
        // Preenche o valor de altura da mídia no modal
        const isRelogio = (relogioBox.style.display === 'flex' && pa.container.style.width === '280px');
        document.getElementById('input-altura-midia').value = isRelogio ? pa.container.offsetHeight : 480; 
        
        controlsContainer.style.display = 'none'; 
        presetLivreModal.style.display = 'block'; 
    }
    
    function fecharModalPresetLivre() { presetLivreModal.style.display = 'none'; }
    
    function aplicarPresetLivre() { 
        if (!checkPlayerAtivo()) return;
        const pa = playerAtivo;
        const x = document.getElementById('input-x').value; 
        const y = document.getElementById('input-y').value; 
        const largura = document.getElementById('input-largura').value; 
        const altura = document.getElementById('input-altura').value; 
        
        resetarLayout(); 
        
        pa.container.style.transform = 'none'; 
        pa.container.style.left = `${x}px`; 
        pa.container.style.top = `${y}px`; 
        pa.container.style.width = `${largura}px`; 
        pa.container.style.height = `${altura}px`; 
        
        fecharModalPresetLivre(); 
    }

    // --- Funções de Corte (Crop) ---
    function toggleCortar(element) {
        if (!checkPlayerAtivo()) return;
        const pa = playerAtivo;
        
        cortarAtivo = !cortarAtivo;
        element.classList.toggle('active', cortarAtivo);
        pa.overlay.style.display = cortarAtivo ? 'block' : 'none';
        
        if (cortarAtivo && moverAtivo) {
            toggleMover(document.querySelector('#move-button-li a'));
        }
    }
    
    /**
     * (MODIFICADO) Reseta o corte e o modo de ajuste.
     */
    function resetarCorte() {
        if (!playerAtivo) return;
        const pa = playerAtivo;
        
        // Reseta o estado do corte salvo
        pa.crop = { x: 0, y: 0, w: 0, h: 0 }; 
        
        // Define o modo de ajuste padrão ('contain')
        pa.media.style.objectFit = 'contain';
        pa.fallback.style.objectFit = 'contain';
        
        // (MODIFICADO) Chama a função de reaplicar para atualizar a mídia ativa
        reaplicarEstilosMidia(pa);

        // Atualiza os botões do menu
        document.querySelectorAll('.menu-grid a[onclick*="ajustarModo"]').forEach(a => a.classList.remove('active')); 
        const containBtn = document.querySelector('.menu-grid a[onclick*="ajustarModo(\'contain\'"]');
        if (containBtn) containBtn.classList.add('active');
    }

    // --- Funções de Salvar/Carregar Mosaico ---
    // (NOTA: A playlist em si não é salva, pois os 'File objects' não podem ser
    // serializados no localStorage. Apenas o layout é salvo.)
    function salvarConfiguracao() {
        const configMosaico = players.map(p => {
            return {
                id: p.id,
                pos: { top: p.container.style.top, left: p.container.style.left },
                tam: { width: p.container.style.width, height: p.container.style.height },
                transform: p.container.style.transform,
                modoAjuste: p.media.style.objectFit || 'contain',
                crop: p.crop,
                rotacao: p.rotacao,
                resize: p.container.style.resize // Salva o estado do resize
            };
        });
        localStorage.setItem('configPlayerMosaico', JSON.stringify(configMosaico));
        alert(`Configuração do mosaico com ${players.length} players foi salva! (Mídias não são salvas)`);
    }

    function carregarConfiguracao() {
        const configStr = localStorage.getItem('configPlayerMosaico');
        if (!configStr) {
            alert('Nenhuma configuração de mosaico salva.');
            return;
        }
        
        const configMosaico = JSON.parse(configStr);
        
        // (MODIFICADO) Limpa timers (imagem e grade) antes de remover os players
        players.forEach(p => {
            if (p.imageTimeout) clearTimeout(p.imageTimeout);
            if (p.gradeCheckInterval) clearInterval(p.gradeCheckInterval); // <--- NOVO
            p.container.remove();
        });
        players = [];
        playerSelector.innerHTML = '';
        playerCounter = 0;
        playerAtivo = null;
        
        if (commercialBarInterval) clearInterval(commercialBarInterval);
        relogioBox.style.display = 'none';
        
        configMosaico.forEach(config => {
            adicionarPlayer(); 
            const pa = playerAtivo; // adicionarPlayer define o playerAtivo
            
            pa.container.style.top = config.pos.top;
            pa.container.style.left = config.pos.left;
            pa.container.style.width = config.tam.width;
            pa.container.style.height = config.tam.height;
            pa.container.style.transform = config.transform;
            pa.container.style.resize = config.resize || 'both'; // Restaura o resize
            
            // Aplica o modo de ajuste
            pa.media.style.objectFit = config.modoAjuste;
            pa.fallback.style.objectFit = config.modoAjuste;
            const modoBtn = document.querySelector(`.menu-grid a[onclick*="'${config.modoAjuste}'"]`);
            if (modoBtn) {
                 document.querySelectorAll('.menu-grid a[onclick*="ajustarModo"]').forEach(a => a.classList.remove('active')); 
                 modoBtn.classList.add('active');
            }
            
            // Aplica rotação e corte
            pa.rotacao = config.rotacao || 0;
            pa.crop = config.crop || { x: 0, y: 0, w: 0, h: 0 };
            reaplicarEstilosMidia(pa); // Aplica ambos
        });
        
        if (players.length > 0) {
            selecionarPlayer(players[0].id);
        }
        
        // Garante que o estado do botão 'mover' corresponda ao estado carregado
        moverAtivo = (playerAtivo && playerAtivo.container.style.resize === 'none');
        const moverBtn = document.querySelector('#move-button-li a');
        if (moverBtn) moverBtn.classList.toggle('active', moverAtivo);

        alert(`Configuração do mosaico com ${players.length} players foi carregada! (É preciso recarregar as mídias)`);
    }

    // ========================================================================
    // --- INICIALIZAÇÃO DA APLICAÇÃO ---
    // ========================================================================
    
    document.addEventListener('DOMContentLoaded', () => {
        // Cria o Player 1 automaticamente ao carregar a página
        adicionarPlayer();
    });

</script>

</body>
</html>
